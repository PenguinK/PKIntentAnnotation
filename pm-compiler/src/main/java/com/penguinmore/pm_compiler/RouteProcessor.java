package com.penguinmore.pm_compiler;

import com.penguinmore.pm_annotation.Route;
import com.squareup.javapoet.ClassName;
import com.squareup.javapoet.JavaFile;
import com.squareup.javapoet.MethodSpec;
import com.squareup.javapoet.ParameterSpec;
import com.squareup.javapoet.ParameterizedTypeName;
import com.squareup.javapoet.TypeSpec;
import com.squareup.javapoet.WildcardTypeName;

import java.io.IOException;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Map;
import java.util.Set;

import javax.annotation.processing.AbstractProcessor;
import javax.annotation.processing.Filer;
import javax.annotation.processing.Messager;
import javax.annotation.processing.ProcessingEnvironment;
import javax.annotation.processing.RoundEnvironment;
import javax.annotation.processing.SupportedAnnotationTypes;
import javax.annotation.processing.SupportedOptions;
import javax.lang.model.SourceVersion;
import javax.lang.model.element.Element;
import javax.lang.model.element.Modifier;
import javax.lang.model.element.TypeElement;
import javax.lang.model.util.Elements;
import javax.tools.Diagnostic;


@SupportedAnnotationTypes("com.penguinmore.pm_annotation.Route")
@SupportedOptions("moduleName")
public class RouteProcessor extends AbstractProcessor {

    public static final String METHOD_NAME_HANDLE = "handle";
    private Messager mLogger;
    private Filer mFiler;
    private Elements mElements;
    private String mModuleName;
    private static final String MODULE_NAME = "moduleName";
    public static final String ACTIVITY_FULL_NAME = "android.app.Activity";
    public static final String INTERFACE_PACKAGE_NAME = "com.penguinmore.pm_router";
    public static final String PACKAGE_NAME = "com.penguinmore.router";
    public static final String ROUTE_TABLE = "RouteTable";
    public static final String ROUTE_TABLE_FULL_NAME = INTERFACE_PACKAGE_NAME + ".template." + ROUTE_TABLE;
    public static final String CLASS_JAVA_DOC = "Generated by PMRouter. Do not edit it!\n";


    @Override
    public SourceVersion getSupportedSourceVersion() {
        return SourceVersion.latest();
    }

    @Override
    public synchronized void init(ProcessingEnvironment processingEnv) {
        super.init(processingEnv);
        mLogger = processingEnv.getMessager();
        mFiler = processingEnv.getFiler();
        mElements = processingEnv.getElementUtils();
        mModuleName = processingEnv.getOptions().get(MODULE_NAME);
    }

    @Override
    public boolean process(Set<? extends TypeElement> annotations, RoundEnvironment roundEnv) {
        mLogger.printMessage(Diagnostic.Kind.WARNING, mModuleName);

        Set<? extends Element> elements = roundEnv.getElementsAnnotatedWith(Route.class);

        if (null == elements || elements.size() == 0) {
            return true;
        }

        Set<TypeElement> validatedElements = new HashSet<>();

        for (Element element : elements) {

            if (element.getKind().isClass() && validateClass((TypeElement) element)) {
                validatedElements.add((TypeElement) element);
            }


            //TODO else method
        }

        if (mModuleName != null) {
            generateRouteTable(mModuleName, validatedElements);
        }

        return true;
    }

    private void generateRouteTable(String mModuleName, Set<TypeElement> validatedElements) {
        if (null == validatedElements || validatedElements.size() == 0) {
            return;
        }
        ParameterizedTypeName mapTypeName = ParameterizedTypeName.get(ClassName.get(Map.class)
                , ClassName.get(String.class)
                , ParameterizedTypeName.get(ClassName.get(Class.class)
                        , WildcardTypeName.subtypeOf(Object.class)));


        ParameterSpec spec = ParameterSpec.builder(mapTypeName, "map").build();

        MethodSpec.Builder handleMethod = MethodSpec.methodBuilder(METHOD_NAME_HANDLE)
                .addAnnotation(Override.class)
                .addModifiers(Modifier.PUBLIC)
                .addParameter(spec);

        Map<String, String> pathRecords = new HashMap<>();

        for (TypeElement element : validatedElements) {

            Route route = element.getAnnotation(Route.class);
            String path = route.path();


            if (pathRecords.containsKey(path)) {
                throw new RuntimeException(String.format("Duplicate route path: %s[%s, %s]",
                        path, element.getQualifiedName(), pathRecords.get(path)));
            }
            handleMethod.addStatement("map.put($S, $T.class)", path, ClassName.get(element));
            pathRecords.put(path, element.getQualifiedName().toString());


        }

        TypeElement interfaceType = processingEnv.getElementUtils().getTypeElement(ROUTE_TABLE_FULL_NAME);
        TypeSpec typeSpec = TypeSpec.classBuilder(capitalize(mModuleName) + ROUTE_TABLE)
                .addSuperinterface(ClassName.get(interfaceType))
                .addModifiers(Modifier.PUBLIC)
                .addMethod(handleMethod.build())
                .addJavadoc(CLASS_JAVA_DOC)
                .build();

        try {
            JavaFile.builder(PACKAGE_NAME, typeSpec).build().writeTo(processingEnv.getFiler());
        } catch (IOException e) {
            e.printStackTrace();
        }

    }


    private String capitalize(CharSequence self) {
        return self.length() == 0 ? "" :
                "" + Character.toUpperCase(self.charAt(0)) + self.subSequence(1, self.length());
    }

    /***
     * validate class is subtype of android.app.Activity,and the class is a abstract class.
     * @param typeElement
     * @return
     */
    private boolean validateClass(TypeElement typeElement) {
        //TODO add Fragment support
        if (!isSubtype(typeElement, ACTIVITY_FULL_NAME)) {
            mLogger.printMessage(Diagnostic.Kind.ERROR, String.format("%s is not a subclass of Activity",
                    typeElement.getSimpleName().toString()));
            return false;
        }
        Set<Modifier> modifiers = typeElement.getModifiers();

        if (modifiers.contains(Modifier.ABSTRACT)) {
            mLogger.printMessage(Diagnostic.Kind.ERROR, String.format("The class %s is abstract. You can't annotate abstract classes with @%s.",
                    (typeElement).getQualifiedName(), Route.class.getSimpleName()));
            return false;
        }
        return true;

    }

    private boolean isSubtype(Element typeElement, String type) {
        return processingEnv.getTypeUtils().isSubtype(typeElement.asType(),
                processingEnv.getElementUtils().getTypeElement(type).asType());
    }
}
